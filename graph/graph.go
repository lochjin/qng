package graph

import (
	"context"
	"errors"
	"fmt"
)

// END is a special constant used to represent the end node in the graph.
const END = "END"

var (
	// ErrEntryPointNotSet is returned when the entry point of the graph is not set.
	ErrEntryPointNotSet = errors.New("entry point not set")

	// ErrNodeNotFound is returned when a node is not found in the graph.
	ErrNodeNotFound = errors.New("node not found")

	// ErrNoOutgoingEdge is returned when no outgoing edge is found for a node.
	ErrNoOutgoingEdge = errors.New("no outgoing edge found for node")
)

type State map[string]interface{}

// Node represents a node in the message graph.
type NodeFunction func(ctx context.Context, name string, state State) (State, error)

// Edge represents an edge in the message graph.
type EdgeFunction func(ctx context.Context, name string, state State) string

type Edge struct {
	// From is the name of the node from which the edge originates.
	From string

	// To is the name of the node to which the edge points and is generated by the condition function.
	To EdgeFunction
}

// Graph represents a message graph.
type Graph[I, O any] struct {
	// nodes is a map of node names to their corresponding Node objects.
	nodes map[string]Node

	// edges is a slice of Edge objects representing the connections between nodes.
	edges []Edge

	// entryPoint is the name of the entry point node in the graph.
	entryPoint string

	options Config
}

// NewGraph creates a new instance of Graph.
func NewGraph[I, O any](opts ...Option) *Graph[I, O] {
	options := Config{}

	for _, opt := range opts {
		opt(&options)
	}

	return &Graph[I, O]{
		nodes:   make(map[string]Node),
		options: options,
	}
}

// AddNode adds a new node to the message graph with the given name and function.
func (g *Graph[I, O]) AddNode(name string, fn NodeFunction) {
	g.nodes[name] = NewBaseNode(name, fn)
}

// AddEdge adds a new edge to the message graph between the "from" and "to" nodes.
func (g *Graph[I, O]) AddEdge(from, to string) {
	g.edges = append(g.edges, Edge{
		From: from,
		To: func(_ context.Context, name string, state State) string {
			// direct edge doesn't have a condition function
			return to
		},
	})
}

// AddConditionalEdge adds a new conditional edge to the message graph between the "from" and the conditional "to" generated by the condition function.
func (g *Graph[I, O]) AddConditionalEdge(from string, condition EdgeFunction) {
	g.edges = append(g.edges, Edge{
		From: from,
		To:   condition,
	})
}

// SetEntryPoint sets the entry point node name for the message graph.
func (g *Graph[I, O]) SetEntryPoint(name string) {
	g.entryPoint = name
}

// Runnable represents a compiled message graph that can be invoked.
type Runnable[I, O any] struct {
	// graph is the underlying Graph object.
	graph *Graph[I, O]
}

// Compile compiles the message graph and returns a Runnable instance.
// It returns an error if the entry point is not set.
func (g *Graph[I, O]) Compile() (*Runnable[I, O], error) {
	if g.entryPoint == "" {
		return nil, ErrEntryPointNotSet
	}

	return &Runnable[I, O]{
		graph: g,
	}, nil
}

// Invoke executes the compiled message graph with the given input messages.
// It returns the resulting messages and an error if any occurs during the execution.
// Invoke executes the compiled message graph with the given input messages.
// It returns the resulting messages and an error if any occurs during the execution.
func (r *Runnable[I, O]) Invoke(ctx context.Context, state State) (State, error) {
	currentNode := r.graph.entryPoint

	for {
		if currentNode == END {
			break
		}

		node, ok := r.graph.nodes[currentNode]
		if !ok {
			return nil, fmt.Errorf("%w: %s", ErrNodeNotFound, currentNode)
		}

		graphOpts := r.graph.options

		if graphOpts.NodeStartHandler != nil {
			graphOpts.NodeStartHandler.NodeStart(ctx, currentNode, state)
		}

		var err error
		state, err = node.GetNodeFunction()(ctx, node.GetName(), state)
		if graphOpts.NodeEndHandler != nil {
			graphOpts.NodeEndHandler.NodeEnd(ctx, currentNode, state)
		}
		if err != nil {
			return nil, fmt.Errorf("error in node %s: %w", currentNode, err)
		}

		foundNext := false
		for _, edge := range r.graph.edges {
			if edge.From == currentNode {
				if graphOpts.EdgeEntryHandler != nil {
					graphOpts.EdgeEntryHandler.EdgeEntry(ctx, edge.From, state)
				}
				nextNode := edge.To(ctx, edge.From, state)
				if graphOpts.EdgeExitHandler != nil {
					graphOpts.EdgeExitHandler.EdgeExit(ctx, edge.From, state, nextNode)
				}
				currentNode = nextNode
				foundNext = true
				break
			}
		}

		if !foundNext {
			return nil, fmt.Errorf("%w: %s", ErrNoOutgoingEdge, currentNode)
		}
	}

	return state, nil
}
