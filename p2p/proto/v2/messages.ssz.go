// Code generated by fastssz. DO NOT EDIT.
// Hash: d4b07a61cef17f5467c1513c6eae92da529bcf615ab32c1380b977b786101c56
// Version: 0.1.2
package qitmeer_p2p_v2

import (
	v1 "github.com/Qitmeer/qng/p2p/proto/v1"
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the ChainState object
func (c *ChainState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ChainState object to a target array
func (c *ChainState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(37)

	// Offset (0) 'GenesisHash'
	dst = ssz.WriteOffset(dst, offset)
	if c.GenesisHash == nil {
		c.GenesisHash = new(v1.Hash)
	}
	offset += c.GenesisHash.SizeSSZ()

	// Field (1) 'ProtocolVersion'
	dst = ssz.MarshalUint32(dst, c.ProtocolVersion)

	// Field (2) 'Timestamp'
	dst = ssz.MarshalUint64(dst, c.Timestamp)

	// Field (3) 'Services'
	dst = ssz.MarshalUint64(dst, c.Services)

	// Field (4) 'DisableRelayTx'
	dst = ssz.MarshalBool(dst, c.DisableRelayTx)

	// Offset (5) 'GraphState'
	dst = ssz.WriteOffset(dst, offset)
	if c.GraphState == nil {
		c.GraphState = new(v1.GraphState)
	}
	offset += c.GraphState.SizeSSZ()

	// Offset (6) 'UserAgent'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.UserAgent)

	// Offset (7) 'MeerState'
	dst = ssz.WriteOffset(dst, offset)
	if c.MeerState == nil {
		c.MeerState = new(MeerState)
	}
	offset += c.MeerState.SizeSSZ()

	// Field (0) 'GenesisHash'
	if dst, err = c.GenesisHash.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'GraphState'
	if dst, err = c.GraphState.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (6) 'UserAgent'
	if size := len(c.UserAgent); size > 256 {
		err = ssz.ErrBytesLengthFn("ChainState.UserAgent", size, 256)
		return
	}
	dst = append(dst, c.UserAgent...)

	// Field (7) 'MeerState'
	if dst, err = c.MeerState.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ChainState object
func (c *ChainState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 37 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o5, o6, o7 uint64

	// Offset (0) 'GenesisHash'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 37 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'ProtocolVersion'
	c.ProtocolVersion = ssz.UnmarshallUint32(buf[4:8])

	// Field (2) 'Timestamp'
	c.Timestamp = ssz.UnmarshallUint64(buf[8:16])

	// Field (3) 'Services'
	c.Services = ssz.UnmarshallUint64(buf[16:24])

	// Field (4) 'DisableRelayTx'
	c.DisableRelayTx = ssz.UnmarshalBool(buf[24:25])

	// Offset (5) 'GraphState'
	if o5 = ssz.ReadOffset(buf[25:29]); o5 > size || o0 > o5 {
		return ssz.ErrOffset
	}

	// Offset (6) 'UserAgent'
	if o6 = ssz.ReadOffset(buf[29:33]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'MeerState'
	if o7 = ssz.ReadOffset(buf[33:37]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Field (0) 'GenesisHash'
	{
		buf = tail[o0:o5]
		if c.GenesisHash == nil {
			c.GenesisHash = new(v1.Hash)
		}
		if err = c.GenesisHash.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (5) 'GraphState'
	{
		buf = tail[o5:o6]
		if c.GraphState == nil {
			c.GraphState = new(v1.GraphState)
		}
		if err = c.GraphState.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (6) 'UserAgent'
	{
		buf = tail[o6:o7]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(c.UserAgent) == 0 {
			c.UserAgent = make([]byte, 0, len(buf))
		}
		c.UserAgent = append(c.UserAgent, buf...)
	}

	// Field (7) 'MeerState'
	{
		buf = tail[o7:]
		if c.MeerState == nil {
			c.MeerState = new(MeerState)
		}
		if err = c.MeerState.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ChainState object
func (c *ChainState) SizeSSZ() (size int) {
	size = 37

	// Field (0) 'GenesisHash'
	if c.GenesisHash == nil {
		c.GenesisHash = new(v1.Hash)
	}
	size += c.GenesisHash.SizeSSZ()

	// Field (5) 'GraphState'
	if c.GraphState == nil {
		c.GraphState = new(v1.GraphState)
	}
	size += c.GraphState.SizeSSZ()

	// Field (6) 'UserAgent'
	size += len(c.UserAgent)

	// Field (7) 'MeerState'
	if c.MeerState == nil {
		c.MeerState = new(MeerState)
	}
	size += c.MeerState.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the ChainState object
func (c *ChainState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ChainState object with a hasher
func (c *ChainState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisHash'
	if err = c.GenesisHash.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'ProtocolVersion'
	hh.PutUint32(c.ProtocolVersion)

	// Field (2) 'Timestamp'
	hh.PutUint64(c.Timestamp)

	// Field (3) 'Services'
	hh.PutUint64(c.Services)

	// Field (4) 'DisableRelayTx'
	hh.PutBool(c.DisableRelayTx)

	// Field (5) 'GraphState'
	if err = c.GraphState.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (6) 'UserAgent'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.UserAgent))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(c.UserAgent)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (7) 'MeerState'
	if err = c.MeerState.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ChainState object
func (c *ChainState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the MeerState object
func (m *MeerState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MeerState object to a target array
func (m *MeerState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Offset (0) 'Id'
	dst = ssz.WriteOffset(dst, offset)
	if m.Id == nil {
		m.Id = new(v1.Hash)
	}
	offset += m.Id.SizeSSZ()

	// Field (1) 'Number'
	dst = ssz.MarshalUint64(dst, m.Number)

	// Offset (2) 'Enode'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Enode)

	// Offset (3) 'Enr'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Enr)

	// Field (0) 'Id'
	if dst, err = m.Id.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Enode'
	if size := len(m.Enode); size > 256 {
		err = ssz.ErrBytesLengthFn("MeerState.Enode", size, 256)
		return
	}
	dst = append(dst, m.Enode...)

	// Field (3) 'Enr'
	if size := len(m.Enr); size > 256 {
		err = ssz.ErrBytesLengthFn("MeerState.Enr", size, 256)
		return
	}
	dst = append(dst, m.Enr...)

	return
}

// UnmarshalSSZ ssz unmarshals the MeerState object
func (m *MeerState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2, o3 uint64

	// Offset (0) 'Id'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Number'
	m.Number = ssz.UnmarshallUint64(buf[4:12])

	// Offset (2) 'Enode'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Enr'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'Id'
	{
		buf = tail[o0:o2]
		if m.Id == nil {
			m.Id = new(v1.Hash)
		}
		if err = m.Id.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Enode'
	{
		buf = tail[o2:o3]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.Enode) == 0 {
			m.Enode = make([]byte, 0, len(buf))
		}
		m.Enode = append(m.Enode, buf...)
	}

	// Field (3) 'Enr'
	{
		buf = tail[o3:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.Enr) == 0 {
			m.Enr = make([]byte, 0, len(buf))
		}
		m.Enr = append(m.Enr, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MeerState object
func (m *MeerState) SizeSSZ() (size int) {
	size = 20

	// Field (0) 'Id'
	if m.Id == nil {
		m.Id = new(v1.Hash)
	}
	size += m.Id.SizeSSZ()

	// Field (2) 'Enode'
	size += len(m.Enode)

	// Field (3) 'Enr'
	size += len(m.Enr)

	return
}

// HashTreeRoot ssz hashes the MeerState object
func (m *MeerState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MeerState object with a hasher
func (m *MeerState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Id'
	if err = m.Id.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Number'
	hh.PutUint64(m.Number)

	// Field (2) 'Enode'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(m.Enode))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(m.Enode)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (3) 'Enr'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(m.Enr))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(m.Enr)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MeerState object
func (m *MeerState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}
